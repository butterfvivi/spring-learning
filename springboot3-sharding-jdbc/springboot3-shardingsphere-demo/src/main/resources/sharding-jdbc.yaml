mode:
  type: Standalone
dataSources:
  ds_0: # 数据源名称317a_master
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource # 数据源完整类名
    driverClassName: com.mysql.cj.jdbc.Driver # 数据库驱动类名，以数据库连接池自身配置为准
    jdbcUrl: jdbc:mysql://14.103.123.142:3307/spheresharding-demo?characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowMultiQueries=true # 数据库 URL 连接，以数据库连接池自身配置为
    username: root # 数据库用户名，以数据库连接池自身配置为准
    password: 123456 # 数据库密码，以数据库连接池自身配置为准
  ds_1: # 327a_master
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource # 数据源完整类名
    driverClassName: com.mysql.cj.jdbc.Driver # 数据库驱动类名，以数据库连接池自身配置为准
    jdbcUrl: jdbc:mysql://14.103.123.142:3308/spheresharding-demo?characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowMultiQueries=true # 数据库 URL 连接，以数据库连接池自身配置为
    username: root # 数据库用户名，以数据库连接池自身配置为准
    password: 123456 # 数据库密码，以数据库连接池自身配置为准
  ds_2: #337a_master
    dataSourceClassName: com.zaxxer.hikari.HikariDataSource # 数据源完整类名
    driverClassName: com.mysql.cj.jdbc.Driver # 数据库驱动类名，以数据库连接池自身配置为准
    jdbcUrl: jdbc:mysql://14.103.123.142:3309/spheresharding-demo?characterEncoding=utf-8&useSSL=false&serverTimezone=Asia/Shanghai&allowMultiQueries=true # 数据库 URL 连接，以数据库连接池自身配置为
    username: root # 数据库用户名，以数据库连接池自身配置为准
    password: 123456 # 数据库密码，以数据库连接池自身配置为准\
rules:
  #读写分离
  - !READWRITE_SPLITTING
    dataSourceGroups:
      ds:  # 这个名字可以自己定义，数据分片的时候会用到
        writeDataSourceName: ds_0 #写库数据源的名称，dataSources下定义的数据源
        readDataSourceNames:
          - ds_1 #读库数据源的名称，ds_0 的读/从库，dataSources 下定义的数据源
          - ds_2 #读库数据源的名称，ds_0 的读/从库，dataSources 下定义的数据源
        transactionalReadQueryStrategy: PRIMARY
        loadBalancerName: random
    loadBalancers:
      random:
        type: ROUND_ROBIN

  - !SHARDING
    # 数据分片
    tables:
      t_order: # 表名，数据库里是t_order0 ,t_order1 这里写 t_order
        actualDataNodes: ds_${0..2}.t_order${0..1}
        databaseStrategy: # 数据库分片策略
          standard:
            shardingColumn: user_id
            shardingAlgorithmName: database_inline
        tableStrategy: # 数据库表分片策略
          standard:
            shardingColumn: order_no
            shardingAlgorithmName: t_order_inline
        keyGenerateStrategy: # 主键生成策略
          column: id #分布式id字段是哪个
          keyGeneratorName: snowflake
      t_order_item: # 表名，数据库里是t_order_item0 ,t_order_item1 这里写 t_order_item
        actualDataNodes: ds_${0..2}.t_order_item${0..1}
        databaseStrategy: # 数据库分片策略
          standard:
            shardingColumn: user_id
            shardingAlgorithmName: database_inline
        tableStrategy: # 数据库表分片策略
          standard:
            shardingColumn: order_no
            shardingAlgorithmName: t_order_item_inline
        keyGenerateStrategy: # 主键生成策略
          column: id #分布式id字段是哪个
          keyGeneratorName: snowflake

    # 订单表拆分成订单主表，订单子表，都通过order_no 分片就需要绑定到一块，查询完整订单的时候好查询
    bindingTables:
      - t_order,t_order_item

    #分片算法
    shardingAlgorithms:
      database_inline:
        type: INLINE
        props:
          # 根据用户id 对3（因为有3个主/写数据库）取余数
          algorithm-expression: ds_${user_id % 3}
      t_order_inline:
        type: CLASS_BASED
        props:
          strategy: STANDARD
            # 下边类是自己写的就是自定义分片算法，这个是shardingsphere 自带的
            # 就是对分片字段（在使用t_order_inline的算法那里有定义） hash 在通过sharding-count的数量取余分片
          algorithmClassName: org.apache.shardingsphere.sharding.algorithm.sharding.mod.HashModShardingAlgorithm
          sharding-count: 2
      t_order_item_inline: # 自定义的算法名称，上边有用到
        type: CLASS_BASED
        props:
          strategy: STANDARD
          # 下边类是自己写的就是自定义分片算法，这个是shardingsphere 自带的
          # 就是对 分片字段（在使用t_order_item_inline的算法那里有定义） hash 在通过sharding-count的数量取余分片
          algorithmClassName: org.apache.shardingsphere.sharding.algorithm.sharding.mod.HashModShardingAlgorithm
          sharding-count: 2
    keyGenerators: # # 分布式序列/id 算法配置
      snowflake:
        type: SNOWFLAKE
        props:
          worker-id: 123  # 工作节点 ID
          max-tolerate-time-difference-milliseconds: 100
  - !SINGLE
    tables:
      # MySQL 风格
      - "*.*" # 加载指定单表 ds_0为读写分离数据源,不设置会找不到表
    defaultDataSource: ds_0

props:
  sql-show: true # 日志显示sql
  max-tolerate-time-difference-milliseconds: 10000
